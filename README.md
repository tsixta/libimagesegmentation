# libimagesegmentation
A lightweight and efficient c++11 library for segmentation/image manipulation. The main features are

* Efficiency. The image data are stored in a directly accessible dynamically allocated 2D array.

* Segmentations. There are two special image types that represent multilabel and binary segmentations.
  The segmentation labellings are stored as 1-channel images but can be saved (and loaded) into an RGB file more
  convenient for naked eye.

* Non-numeric images. The images can be seen as advanced 2D arrays that can store objects of (almost)
  arbitrary type. Furthermore 1-channel images can be also saved (and loaded) as CSV files. 

* A function for loading MNIST dataset.

## Installation
Get [CImg](https://github.com/dtschump/CImg) library first.

Cd to `libimagesegmentation` directory and in the terminal run

```Shell
mkdir build
cd build
cmake -DCMAKE_INSTALL_PREFIX:PATH=/usr ..
make
sudo make install
```

In order to use libimagesegmentation in your project include `ImageSegmentation.h`
```C++
#include <imagesegmentation/ImageSegmentation.h>
```
and link the executable with `-limagesegmentation`.

## Manual Compilation
If you prefer to compile the library manually, you may do it by g++:

```Shell
g++ -Dcimg_use_tiff -Wall -pedantic -std=c++11 -O3 -fPIC -shared -o libimagesegmentation.so *.cpp -lX11 -lpthread -ltiff
```

## Documentation
The documentation can be generated by running doxygen from `libimagesegmentation` directory:

```Shell
doxygen Doxyfile
```

The documentation will appear in `doc/html` subdirectory.


## Examples
### Load image/segmentation from file

```C++
#include <iostream>
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  Segmentation seg("test.png");//Load multilabel segmentation from file
  SegmentationBW segBW("test.png");//Load binary segmentation from file
  ImageRGB imgrgb("test.png");//Load an RGB image
  Image<int> img("test.png");//Load a grayscale image with underlying type int
  ImageSegmentation<int,4> imgseg4("test.png");//Load a 4-channel image with underlying type int
  
  seg.load("test.png");//Load multilabel segmentation from file
  seg.load_csv("test.csv");//Load multilabel segmentation from a csv file
  img.load_csv("test.csv");//Load a grayscale image from a csv file

  int x=25,y=53;
  std::cout << "Pixel " << Pixel<int>(x,y) << ":" << std::endl;
  std::cout << "seg: " << seg.data[x][y] << std::endl;
  std::cout << "segBW: " << segBW.data[x][y] << std::endl;
  std::cout << "imgrgb: " << imgrgb.data[x][y] << std::endl;
  std::cout << "img: " << img.data[x][y] << std::endl;
  std::cout << "imgseg4: " << imgseg4.data[x][y] << std::endl;
  
  return(0);
}
```

### Save image/segmentation into a file
```C++
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  Segmentation seg("test.png");//Load multilabel segmentation from file
  SegmentationBW segBW("test.png");//Load binary segmentation from file
  ImageRGB imgrgb("test.png");//Load an RGB image
  Image<int> img("test.png");//Load a grayscale image with underlying type int
  
  seg.save("test_seg.png");//Save multilabel segmentation into a file
  seg.save_bw("test_seg_bw.png");//Save multilabel segmentation into a file as binary segmentation
  seg.save_csv("test_seg_csv.csv");//Save multilabel segmentation into a CSV file
  segBW.save("test_segbw.png");//Save binary segmentation into a file
  segBW.save_segmentation("test_segbw_segmentation.png");//Save binary segmentation into a file as multilabel segmentation
  segBW.save_csv("test_segbw_csv.csv");//Save binary segmentation into a CSV file
  imgrgb.save("test_imgrgb.png");//Save RGB image into a file
  img.save("test_img.png");//Save grayscale image into a file
  
  return(0);
}
```

### Drawing
```C++
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  ImageRGB imgrgb(100,100);//Create new 100x100 RGB image
  imgrgb.draw_line(Pixel<int>(10,15),Pixel<int>(60,70),Color<int,3>({108,164,64}));
  imgrgb.draw_circle(Pixel<int>(50,50),15,Color<int,3>({255,0,0}));
  imgrgb.draw_text(Pixel<int>(0,0),"Text",15,Color<int,3>({255,255,0}),Color<int,3>({24,24,24}));
  imgrgb.save("draw.png")
  return(0);
}
```

### Global manipulation
```C++
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  Segmentation seg("test.png");//Load a segmentation
  Segmentation segBackup(seg);//Duplicate seg
  seg.resize(5,CImgInterpolation::NearestNeighbor);//Magnify seg by factor 5
  Segmentation otherColumn;//Create empty segmentation
  //Stitch three segBackup in a column
  for(int i=0;i<3;i++) otherColumn.stitch(segBackup,Position::Bottom,Position::Left);
 
  //Attach otherColumn to the right edge of seg and draw 20 px thick dividing line using color (label) 2
  //and fill background pixels with color (label) 7
  seg.stitch(otherColumn,Position::Right,Position::Center,7,20,2);
  seg.save("global.png")

  return(0);
}
```

### Flood fill
```C++
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  Segmentation seg("test.png");//Load a segmentation
  Pixel<int> startingPoint(48,77);
  std::vector<Pixel<int> > floodedPixels;
  //Flood region attached to pixel [48,11] with color (label) 7
  seg.flood_fill(startingPoint,7,floodedPixels);
  seg.save("floodfill1.png")
  //Custom color equality function
  auto equalsFunction=[](int c1,int c2){return(abs(c1-c2)<=1);};
  seg.load("test.png");
  seg.flood_fill(startingPoint,7,equalsFunction,floodedPixels);
  seg.save("floodfill2.png")
  return(0);
}
```

### MNIST
```C++
#include <imagesegmentation/ImageSegmentation.h>
using namespace LibImageSegmentation;
int main(int argc,char **argv)
{
  std::vector<SegmentationBW> images;
  std::vector<int> labels;
  //Load MNIST dataset as binary segmentations thresholded at 127
  load_mnist("/path/to/mnist/dataset","",images,labels,127);
  int r=5,c=5;
  int a=0;
  //Visualize first c*r digits
  SegmentationBW vis(c*28,r*28);
  for(int i=0;i<c;i++)
  {
    for(int j=0;j<r;j++)
    {
      vis.copy_data(images[a],i*28,j*28);
      a++;
    }
  }
  vis.save("mnist.png");
  return(0);
}
```


